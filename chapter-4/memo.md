# データ構造

- データの集合
    - 対象となるデータの本体
    - 基本データ構造でデータの集合を保持する
- 規則
    - データの集合を一定のルールに従って正しく操作・管理・保持するための決まり事
    - どういった順番でデータを取り出すか、など
- 操作
    - 「要素を挿入する」や「要素を取り出す」などの、データの集合に対する操作
    - 「データの要素数を調べる」や「データの集合が空かどうか調べる」

## スタック

LIFO: Last In First Out
操作

- push(x): スタックのトップに要素xを追加する
- pop(): スタックのトップから要素を取り出す
- isEmpty(): スタックが空かどうかを調べる
- isFull(): スタックが満杯かどうかを調べる

## キュー

- ラウンドロビンスケジューリング
  - プロセスを格納するキューを用いてシミュレートできる

キュー Q の操作

一次元配列

- head
  - キューの先頭の場所を指し示す整数型変数
  - 必ずしもインデックスは 0 とは限らない
    - キューから取り出したあと、インデックスを詰め直しているわけではないため
  - ポインタ
- tail
  - キューの末尾＋1の場所を指し示す整数型変数
  - 次の要素を格納する場所を示す
  - ポインタ
  - head と tail で挟まれた部分（tailが指す部分は除く）がキューの中身
- enqueue(x)
  - `Q[tail]` に x を代入し、tail を一つ増やす
- dequeue()
  - `Q[head]` の値を返し、 head を一つ増やす

## 連結リスト

以下の命令を受け付ける双方向連結リストを実装する。

- insert x
  - 連結リストの先頭にキーxを持つ要素を継ぎ足す
- delete x
  - キーxを持つ最初の要素を連結リストから削除する
- deleteFirst
  - 連結リストの先頭の要素を削除する
- deleteLast
  - 連結リストの末尾の要素を削除する


### 双方向連結リスト

- データ本体（ここでは整数値の key）
- 自分の前の要素へのポインタ prev
- 自分の次の要素へのポインタ next

このリストの各要素を「ノード」と呼ぶことにする。

- **番兵**
  - リストの先頭を指す特別なノード
  - 実データには含めない
  - ポインタの繋ぎ変えが容易になる

番兵を示すノードを `NIL` として実装

- 番兵(NIL) 変数名を nil
  - nil.next = nil
  - nil.prev = nil

### insert

与えられたキーを持つノードを生成し、それをリストの先頭に追加する

**番兵(nil)の直後に要素を追加する**

- 追加する要素 x の　next に現在の番兵の next を代入する
  - x から next
  - x の next がセットされる
- 現在の番兵の next の prev を x にする
  - x の next になる要素から x への prev がセットされる
  - x への prev
- 番兵の next を x にする
- x の prev を番兵にする

### delete
